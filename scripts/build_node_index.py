#!/usr/bin/env python3
"""Build a topologically-sorted node index and a DOT graph.

Outputs (repo root):
- NODE_INDEX.md
- TREE.dot

Deterministic: stable ordering for reproducible diffs.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Dict, List, Tuple

import yaml

REPO = Path(__file__).resolve().parents[1]
NODES_DIR = REPO / "nodes"
OUT_INDEX = REPO / "NODE_INDEX.md"
OUT_DOT = REPO / "TREE.dot"


def load_node_yaml(path: Path) -> dict:
    with path.open("r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def discover_nodes() -> Dict[str, dict]:
    nodes: Dict[str, dict] = {}
    if not NODES_DIR.exists():
        return nodes

    for node_yaml in sorted(NODES_DIR.glob("N*/node.yaml")):
        data = load_node_yaml(node_yaml)
        meta = data.get("meta", {})
        node_id = str(meta.get("id", "")).strip()
        if not node_id:
            continue
        data["__path__"] = str(node_yaml.relative_to(REPO))
        nodes[node_id] = data

    return nodes


def topo_sort(nodes: Dict[str, dict]) -> List[str]:
    # Kahn's algorithm with deterministic tie-breaking
    deps: Dict[str, List[str]] = {}
    rev: Dict[str, List[str]] = {}

    for nid, n in nodes.items():
        d = n.get("depends_on", []) or []
        d = [str(x).strip() for x in d if str(x).strip()]
        deps[nid] = d
        for parent in d:
            rev.setdefault(parent, []).append(nid)

    indeg = {nid: 0 for nid in nodes}
    for nid, d in deps.items():
        indeg[nid] = sum(1 for p in d if p in nodes)

    ready = sorted([nid for nid, k in indeg.items() if k == 0])
    out: List[str] = []

    while ready:
        nid = ready.pop(0)
        out.append(nid)
        for child in sorted(rev.get(nid, [])):
            indeg[child] -= 1
            if indeg[child] == 0:
                ready.append(child)
        ready.sort()

    # If cycle or missing nodes, append remaining deterministically
    remaining = [nid for nid in nodes if nid not in out]
    out.extend(sorted(remaining))
    return out


def build_index(nodes: Dict[str, dict], order: List[str]) -> str:
    lines: List[str] = []
    lines.append("# Node Index (Derivation DAG)")
    lines.append("")
    lines.append("Generated by `scripts/build_node_index.py`. Commit the generated files.")
    lines.append("")

    for nid in order:
        n = nodes[nid]
        meta = n.get("meta", {})
        title = meta.get("title", "")
        status = meta.get("status", "")
        relpath = n.get("__path__", "")
        depends = n.get("depends_on", []) or []
        depends = [str(x).strip() for x in depends if str(x).strip()]
        dep_str = ", ".join(depends) if depends else "(none)"

        lines.append(f"## {nid} â€” {title}")
        lines.append("")
        lines.append(f"- Status: **{status}**")
        lines.append(f"- Node file: `{relpath}`")
        lines.append(f"- Depends on: {dep_str}")
        lines.append("")

    return "\n".join(lines) + "\n"


def build_dot(nodes: Dict[str, dict], order: List[str]) -> str:
    # Simple DOT graph of dependencies
    lines: List[str] = []
    lines.append("digraph Atom21Nodes {")
    lines.append("  rankdir=LR;")
    lines.append("  node [shape=box];")

    for nid in order:
        title = nodes[nid].get("meta", {}).get("title", "")
        label = f"{nid}\\n{title}".replace('"', "'")
        lines.append(f"  \"{nid}\" [label=\"{label}\"]; ")

    for nid in order:
        deps = nodes[nid].get("depends_on", []) or []
        deps = [str(x).strip() for x in deps if str(x).strip()]
        for parent in deps:
            if parent in nodes:
                lines.append(f"  \"{parent}\" -> \"{nid}\";")

    lines.append("}")
    return "\n".join(lines) + "\n"


def main() -> int:
    nodes = discover_nodes()
    order = topo_sort(nodes)

    OUT_INDEX.write_text(build_index(nodes, order), encoding="utf-8", newline="\n")
    OUT_DOT.write_text(build_dot(nodes, order), encoding="utf-8", newline="\n")

    print(f"WROTE: {OUT_INDEX.relative_to(REPO)}")
    print(f"WROTE: {OUT_DOT.relative_to(REPO)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
